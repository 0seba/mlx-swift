import Foundation
import Cmlx

// This file is generated by GenerateGrad.

/// Returns a function which computes the gradient of `f`.
///
///
public func grad(_ f: @escaping ([MLXArray]) -> [MLXArray], argumentNumbers: [Int] = [0]) -> ([MLXArray]) -> [MLXArray] {
    // Converts the given function `f()` into canonical types, e.g.
    // (MLXArray) -> MLXArray into the canonical form ([MLXArray]) -> [MLXArray].
    //
    // First use the wrapArguments() and wrapResult() function to transform
    // it into that form.  Then call buildValueAndGradient() to produce a new
    // function with the same canonical form.
    //
    // Finally use unwrapArguments() and unwrapResult() to transform the function
    // back into the original signature.
    //
    // Note: this particular form of the function is already in the canonical
    // form and the wrap/unwrap calls are identity functions.
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: ([MLXArray]) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping ([MLXArray]) -> MLXArray, argumentNumbers: [Int] = [0]) -> ([MLXArray]) -> MLXArray {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: ([MLXArray]) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping ([MLXArray]) -> (MLXArray, MLXArray), argumentNumbers: [Int] = [0]) -> ([MLXArray]) -> (MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: ([MLXArray]) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping ([MLXArray]) -> (MLXArray, MLXArray, MLXArray), argumentNumbers: [Int] = [0]) -> ([MLXArray]) -> (MLXArray, MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: ([MLXArray]) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray) -> [MLXArray]) -> (MLXArray) -> [MLXArray] {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: [0])
    let uag: (MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray) -> MLXArray) -> (MLXArray) -> MLXArray {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: [0])
    let uag: (MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray) -> (MLXArray, MLXArray)) -> (MLXArray) -> (MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: [0])
    let uag: (MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray) -> (MLXArray, MLXArray, MLXArray)) -> (MLXArray) -> (MLXArray, MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: [0])
    let uag: (MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray) -> [MLXArray], argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray) -> [MLXArray] {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray) -> MLXArray, argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray) -> MLXArray {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray) -> (MLXArray, MLXArray), argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray) -> (MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray) -> (MLXArray, MLXArray, MLXArray), argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray) -> (MLXArray, MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> [MLXArray], argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray, MLXArray) -> [MLXArray] {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> MLXArray, argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray, MLXArray) -> MLXArray {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> (MLXArray, MLXArray), argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray, MLXArray) -> (MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}

/// See ``grad(_:)-7zhu6``
public func grad(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> (MLXArray, MLXArray, MLXArray), argumentNumbers: [Int] = [0]) -> (MLXArray, MLXArray, MLXArray) -> (MLXArray, MLXArray, MLXArray) {
    let wrappedFunction = wrapResult(wrapArguments(f))
    let gradientFunction = buildValueAndGradient(wrappedFunction, argumentNumbers: argumentNumbers)
    let uag: (MLXArray, MLXArray, MLXArray) -> [MLXArray] = unwrapArguments(gradientFunction)
    return unwrapResult(uag)
}


// MARK: - Functions to wrap and unwrap types in closures

@inline(__always)
private func wrapArguments<Result>(_ f: @escaping ([MLXArray]) -> Result) -> ([MLXArray]) -> Result {
    f
}

@inline(__always)
private func wrapResult(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> ([MLXArray]) -> [MLXArray] {
    f
}

@inline(__always)
private func wrapResult(_ f: @escaping ([MLXArray]) -> MLXArray) -> ([MLXArray]) -> [MLXArray] {
    { (arrays: [MLXArray]) in
        [f(arrays)]
    }
}

@inline(__always)
private func unwrapArguments(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> ([MLXArray]) -> [MLXArray] {
    f
}

@inline(__always)
private func unwrapResult(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> ([MLXArray]) -> [MLXArray] {
    f
}

@inline(__always)
private func wrapArguments<Result>(_ f: @escaping (MLXArray) -> Result) -> ([MLXArray]) -> Result {
    { (arrays: [MLXArray]) in
        f(arrays[0])
    }
}

@inline(__always)
private func wrapArguments<Result>(_ f: @escaping (MLXArray, MLXArray) -> Result) -> ([MLXArray]) -> Result {
    { (arrays: [MLXArray]) in
        f(arrays[0], arrays[1])
    }
}

@inline(__always)
private func wrapArguments<Result>(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> Result) -> ([MLXArray]) -> Result {
    { (arrays: [MLXArray]) in
        f(arrays[0], arrays[1], arrays[2])
    }
}

@inline(__always)
private func wrapResult(_ f: @escaping ([MLXArray]) -> (MLXArray, MLXArray)) -> ([MLXArray]) -> [MLXArray] {
    { (arrays: [MLXArray]) in
        let v = f(arrays)
        return [v.0, v.1]
    }
}

@inline(__always)
private func wrapResult(_ f: @escaping ([MLXArray]) -> (MLXArray, MLXArray, MLXArray)) -> ([MLXArray]) -> [MLXArray] {
    { (arrays: [MLXArray]) in
        let v = f(arrays)
        return [v.0, v.1, v.2]
    }
}

@inline(__always)
private func unwrapArguments(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> (MLXArray) -> [MLXArray] {
    { (a0: MLXArray) in
        f([a0])
    }
}

@inline(__always)
private func unwrapArguments(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> (MLXArray, MLXArray) -> [MLXArray] {
    { (a0: MLXArray, a1: MLXArray) in
        f([a0, a1])
    }
}

@inline(__always)
private func unwrapArguments(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> (MLXArray, MLXArray, MLXArray) -> [MLXArray] {
    { (a0: MLXArray, a1: MLXArray, a2: MLXArray) in
        f([a0, a1, a2])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> ([MLXArray]) -> (MLXArray) {
    { (a0: [MLXArray]) in
        let v = f(a0)
        return (v[0])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> ([MLXArray]) -> (MLXArray, MLXArray) {
    { (a0: [MLXArray]) in
        let v = f(a0)
        return (v[0], v[1])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping ([MLXArray]) -> [MLXArray]) -> ([MLXArray]) -> (MLXArray, MLXArray, MLXArray) {
    { (a0: [MLXArray]) in
        let v = f(a0)
        return (v[0], v[1], v[2])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray) -> [MLXArray]) -> (MLXArray) -> [MLXArray] {
    { (a0: MLXArray) in
        f(a0)
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray) -> [MLXArray] {
    { (a0: MLXArray, a1: MLXArray) in
        f(a0, a1)
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray, MLXArray) -> [MLXArray] {
    { (a0: MLXArray, a1: MLXArray, a2: MLXArray) in
        f(a0, a1, a2)
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray) -> [MLXArray]) -> (MLXArray) -> (MLXArray) {
    { (a0: MLXArray) in
        let v = f(a0)
        return (v[0])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray) -> (MLXArray) {
    { (a0: MLXArray, a1: MLXArray) in
        let v = f(a0, a1)
        return (v[0])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray, MLXArray) -> (MLXArray) {
    { (a0: MLXArray, a1: MLXArray, a2: MLXArray) in
        let v = f(a0, a1, a2)
        return (v[0])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray) -> [MLXArray]) -> (MLXArray) -> (MLXArray, MLXArray) {
    { (a0: MLXArray) in
        let v = f(a0)
        return (v[0], v[1])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray) -> (MLXArray, MLXArray) {
    { (a0: MLXArray, a1: MLXArray) in
        let v = f(a0, a1)
        return (v[0], v[1])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray, MLXArray) -> (MLXArray, MLXArray) {
    { (a0: MLXArray, a1: MLXArray, a2: MLXArray) in
        let v = f(a0, a1, a2)
        return (v[0], v[1])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray) -> [MLXArray]) -> (MLXArray) -> (MLXArray, MLXArray, MLXArray) {
    { (a0: MLXArray) in
        let v = f(a0)
        return (v[0], v[1], v[2])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray) -> (MLXArray, MLXArray, MLXArray) {
    { (a0: MLXArray, a1: MLXArray) in
        let v = f(a0, a1)
        return (v[0], v[1], v[2])
    }
}

@inline(__always)
private func unwrapResult(_ f: @escaping (MLXArray, MLXArray, MLXArray) -> [MLXArray]) -> (MLXArray, MLXArray, MLXArray) -> (MLXArray, MLXArray, MLXArray) {
    { (a0: MLXArray, a1: MLXArray, a2: MLXArray) in
        let v = f(a0, a1, a2)
        return (v[0], v[1], v[2])
    }
}

